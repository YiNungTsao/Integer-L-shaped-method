using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ILOG.Concert;
using ILOG.CPLEX;
using System.Collections;

namespace IntegerLShapedMethod
{
    public class DisjunctiveCuts
    {
        public Cplex D_cplex;
        public IObjective D_objective;
        public IRange[] C3LP_IRange;
        public INumVar[] D_INumVar;
        public INumVar[] w;
        public IEnumerator D_mEnum;
        public ILPMatrix D_lpmatrix;
        public ILPMatrix tempLPMatrix;
        public int nPolySet;
        public int numCols = Program.BB.numCols;
        public int numRows = Program.BB.numRows;
        //*************************************************************************************
        // Disjunctive inequalities
        // node id, left-hand-sides, variables, right-hand-sides
        // example:
        // 0.3 y1 + 0.2 y2 >= 0.5 add to node index 0 as d_cut 1 (inheriting from parents)
        // 0.4 y3 + 0.6 y4 >= 1.2 add to node index 0 as d_cut 2 (generated by myself)
        // D_cuts = {0, {<0.3, 0.2>; <0.4, 0.6>}, {<0, 1>;<2,3>}, {0.5;1.2})}
        //*************************************************************************************

        public DisjunctiveCuts()
        {
            D_cplex = new Cplex();
            nPolySet = 2;
        }

        public void C3LPInitialization()
        {
            //C3LP variables
            INumVar[] Pi = new INumVar[numCols + 1];
            ILinearNumExpr D_obj = this.D_cplex.LinearNumExpr();
            for (int c = 0; c < numCols + 1; c++)
            {
                string name = string.Format("Pi_{0}", c);
                Pi[c] = this.D_cplex.NumVar(-1, 1, name);

                D_obj.AddTerm(Pi[c], 1);
            }

            INumVar[][] u = new INumVar[nPolySet][];
            for (int s = 0; s < nPolySet; ++s)
            {
                u[s] = new INumVar[numRows];
                for (int r = 0; r < numRows; ++r)
                {
                    string name = string.Format("u_{0}_{1}", s, (r + 1));
                    u[s][r] = this.D_cplex.NumVar(0.0, double.MaxValue, name);
                    D_obj.AddTerm(u[s][r], 1);
                }
            }

            INumVar[][] v = new INumVar[nPolySet][];
            for (int s = 0; s < nPolySet; ++s)
            {
                v[s] = new INumVar[numCols];
                for (int c = 0; c < numCols; ++c)
                {
                    string name = string.Format("v_{0}_{1}", s, (c + 1));
                    v[s][c] = this.D_cplex.NumVar(0.0, double.MaxValue, name);
                    D_obj.AddTerm(v[s][c], 1);
                }
            }
            this.D_cplex.AddMaximize(D_obj);
            // D_obj.Clear();

            // C3LP constraints (Pi with the number of Ncols constriants and Pi[0] with 1)
            //C3LP_IRange = new IRange[Program.BB.Ncols * 2 + 2];
            ILinearNumExpr D_Constraints = this.D_cplex.LinearNumExpr();
            GetCoefficient(ref Program.BB.A, ref Program.BB.RHS);

            // Constraints for Pi
            for (int s = 0; s < nPolySet; ++s)
            {
                for (int c = 1; c < numCols + 1; ++c)
                {
                    D_Constraints.AddTerm(Pi[c], 1);
                    for (int r = 0; r < numRows; r++)
                        D_Constraints.AddTerm(u[s][r], -Program.BB.A[r, c-1]);

                    if (Program.BB.BinaryVarID.Contains(c))
                        D_Constraints.AddTerm(v[s][c], 1);

                    //C3LP_IRange[count] = D_cplex.AddGe(D_Constraints, 0, string.Format("Pi_{0}_Set_{1}", (c + 1), s));
                    string name = string.Format("Pi_{0}_Set_{1}", (c + 1), s);
                    this.D_cplex.AddGe(D_Constraints, 0, name);
                    D_Constraints.Clear();
                }
            }


            // Constraints for Pi[0]
            for (int s = 0; s < nPolySet; ++s)
            {
                D_Constraints.AddTerm(Pi[0], 1);
                for (int r = 0; r < numRows; ++r)
                    D_Constraints.AddTerm(u[s][r], -Program.BB.RHS[r]);
                foreach (int c in Program.BB.BinaryVarID)
                    D_Constraints.AddTerm(v[s][c], 1);

                //C3LP_IRange[Program.BB.Ncols * 2 + s] = D_cplex.AddLe(D_Constraints, 0, "Pi_0_set_" + s);
                this.D_cplex.AddLe(D_Constraints, 0, "Pi_0_set_" + s);
                D_Constraints.Clear();
            }

            // For D_CutGeneration
            w = new INumVar[nPolySet];
            for (int s = 0; s < nPolySet; ++s)
                w[s] = this.D_cplex.NumVar(0.0, double.MaxValue, "w_" + s);

            this.D_cplex.ExportModel("D_Cut_Initialization.lp");
            this.D_cplex.ImportModel("D_Cut_Initialization.lp");

            this.D_mEnum = this.D_cplex.GetLPMatrixEnumerator();
            this.D_mEnum.MoveNext();
            this.D_lpmatrix = (ILPMatrix)D_mEnum.Current;
            this.C3LP_IRange = this.D_lpmatrix.Ranges;
            this.D_INumVar = this.D_lpmatrix.NumVars;
            this.D_objective = this.D_cplex.GetObjective();
            this.D_INumVar = this.D_lpmatrix.NumVars;

            // Set the Coefficient of Objective function for Original v, u
            for (int i = numCols; i < this.D_INumVar.Length; ++i)
                this.D_cplex.SetLinearCoef(this.D_objective, D_INumVar[i], 0);
        }


        public void GetCoefficient(ref double[,] A, ref double[] RHS)
        {
            // Mapping the INumVar and index
            Dictionary<INumVar, int> MapVarIdx = new Dictionary<INumVar, int>();
            foreach (var item in Program.BB._INumVar.Select((value, index) => new { value, index }))
                MapVarIdx.Add(item.value, item.index);

            //***********************************************************************
            // 1. OverWrite the value of A[,] by existing INumvar(c) in each row (r)
            // 2. Get the RHS
            //***********************************************************************
            IRange[] Allrows = Program.BB.lpmatrix.Ranges;
            INumExpr row;
            ILinearNumExpr rowExpr;
            ILinearNumExprEnumerator rowEnum;

            for (int r = 0; r < Program.BB.lpmatrix.Nrows; r++)
            {
                row = Allrows[r].Expr;
                rowExpr = (ILinearNumExpr)row;
                rowEnum = rowExpr.GetLinearEnumerator();

                // Check Sense
                if (Allrows[r].LB == double.MinValue)
                {
                    // 1. LHS
                    while (rowEnum.MoveNext()) A[r, MapVarIdx[rowEnum.NumVar]] = -1 * rowEnum.Value;
                    // 2. RHS
                    RHS[r] = -1 * Allrows[r].UB;
                }
                else
                {
                    // 1. LHS
                    while (rowEnum.MoveNext()) A[r, MapVarIdx[rowEnum.NumVar]] = rowEnum.Value;
                    // 2. RHS
                    RHS[r] = Allrows[r].LB;
                }
            }
            //System.Console.WriteLine("Done !");
            //System.Console.ReadLine();
        }


        //******************
        // For Testing
        //******************
        public void Write(double[,] A, double[] RHS, int r, int c, string filename)
        {
            System.Text.StringBuilder sb = new StringBuilder();
            // Column(var) name
            foreach (var item in Program.BB._INumVar) sb.Append(item.Name + ",");
            sb.Append("Sense, RHS");
            sb.AppendLine();
            for (int row = 0; row < r; ++row)
            {
                // Coeff
                for (int col = 0; col < c; ++col)
                    sb.Append(A[row, col] + ",");

                // Sense 
                sb.Append("=>,");

                // RHS
                sb.Append(RHS[row]);

                // Move to the next line
                sb.AppendLine();
            }

            System.IO.File.WriteAllText(string.Format("{0}.csv", filename), sb.ToString());
            sb.Clear();
        }

       
        public void D_CutGeneration(int BranchingIdx, string SelectedNodeID, int NodeStatus)
        {
            // Set the Coefficient of Objective Function for Pi
            for (int i = 0; i < numCols + 1; ++i)
            {
                if (i == 0)
                    this.D_cplex.SetLinearCoef(this.D_objective, this.D_INumVar[i], 1);
                else
                    this.D_cplex.SetLinearCoef(this.D_objective, this.D_INumVar[i], -Program.BB.myTree[NodeStatus][SelectedNodeID].AllSln[i-1]);
                    
            }

            TreeNode _TreeNode = Program.BB.myTree[NodeStatus][SelectedNodeID];

            // For new Variable u
            int numBCuts = _TreeNode.BCutsRHS.Count;
            int numDCuts = _TreeNode.DCutRHS.Count;

            // List of IAddable for Removing Column after Solving
            List<IAddable> _IAddableVar = new List<IAddable>();

            // Initialize the size of B_u & D_u
            INumVar[][] B_u = new INumVar[nPolySet][];
            INumVar[][] D_u = new INumVar[nPolySet][];
            for (int s = 0; s < nPolySet; s++)
            {
                if (_TreeNode.DCutRHS.Count != 0)
                {
                    numDCuts = _TreeNode.DCutRHS.Count;
                    D_u[s] = new INumVar[numDCuts];
                    for (int r = 0; r < numDCuts; ++r)
                        D_u[s][r] = this.D_cplex.NumVar(0.0, double.MaxValue, string.Format("D_u_{0}_{1}", s, (r + 1)));
                }

                B_u[s] = new INumVar[numBCuts];
                for (int r = 0; r < numBCuts; ++r)
                    B_u[s][r] = this.D_cplex.NumVar(0.0, double.MaxValue, string.Format("B_u_{0}_{1}", s, (r + 1)));
            }

            //**************************
            // Modify C3LLP Constraints
            //**************************
            // Add Column (Including Coefficient) for D_u
            for (int j = 0; j < numDCuts; ++j)
            {
                Column col_0 = this.D_cplex.Column(this.D_objective,0);
                Column col_1 = this.D_cplex.Column(this.D_objective,0);

                // For Pi
                for (int i = 0; i < numCols + 1; ++i)
                {
                    if (i == 0)
                    {
                        col_0 = col_0.And(this.D_cplex.Column(this.C3LP_IRange[2 * numCols], -1 * _TreeNode.DCutRHS[j]));
                        col_1 = col_1.And(this.D_cplex.Column(this.C3LP_IRange[2 * numCols + 1], -1 * _TreeNode.DCutRHS[j]));
                    }
                    else
                    {
                        col_0 = col_0.And(this.D_cplex.Column(this.C3LP_IRange[i], -1 * _TreeNode.DCutCoeff[j][i-1]));
                        col_1 = col_1.And(this.D_cplex.Column(this.C3LP_IRange[numCols + i], -1 * _TreeNode.DCutCoeff[j][i-1]));
                    }
                }
                string name_0 = string.Format("D_u0_{0}",(j+1));
                string name_1 = string.Format("D_u1_{0}",(j+1));
                D_u[0][j] = this.D_cplex.NumVar(col_0, 0, double.MaxValue, NumVarType.Float, name_0);
                D_u[1][j] = this.D_cplex.NumVar(col_1, 0, double.MaxValue, NumVarType.Float, name_1);
                _IAddableVar.Add(D_u[1][j]);
            }

            // Add Column (Including Coefficient) for B_u
            foreach (var item in _TreeNode.BCutsRHS.Select((value, index) => new { value, index }))
            {
                Column col_0 = this.D_cplex.Column(this.D_objective, 0);
                Column col_1 = this.D_cplex.Column(this.D_objective, 0);
                if (item.value == 0)        // for Bcut <= 0
                {
                    // in Pi
                    col_0 = col_0.And(this.D_cplex.Column(this.C3LP_IRange[_TreeNode.SelectedVarID[item.index]], 1));
                    col_1 = col_1.And(this.D_cplex.Column(this.C3LP_IRange[numCols + _TreeNode.SelectedVarID[item.index]], 1));
                }
                else    // for Bcut >= 1
                {
                    // in Pi
                    col_0 = col_0.And(this.D_cplex.Column(this.C3LP_IRange[_TreeNode.SelectedVarID[item.index]], -1));
                    col_1 = col_1.And(this.D_cplex.Column(this.C3LP_IRange[numCols + _TreeNode.SelectedVarID[item.index]], -1));

                    // in Pi[0]
                    col_0 = col_0.And(this.D_cplex.Column(this.C3LP_IRange[2 * numCols], -1));
                    col_1 = col_1.And(this.D_cplex.Column(this.C3LP_IRange[2 * numCols + 1], -1));
                }
            }

            //w[j] in Pi
            this.D_cplex.SetLinearCoef(this.C3LP_IRange[BranchingIdx], w[0], 1);
            this.D_cplex.SetLinearCoef(this.C3LP_IRange[numCols + BranchingIdx], w[1], -1);

            // w[j] in Pi[0]
            this.D_cplex.SetLinearCoef(this.C3LP_IRange[2 * numCols + 1], w[1], -1);

            //this.D_cplex.ExportModel("D_Cut_Level.lp");
            this.D_cplex.SetOut(null);
            SetAlgorithm.Preprocessing_off(this.D_cplex);
            this.D_cplex.SetParam(Cplex.Param.RootAlgorithm, 0);
            this.D_cplex.Solve();


            // Update D_Cut into ChildNodes 1: For left node, 2:f For right node
            for (int i = 0; i < 2; i++)
            {
                Program.BB.myTree[0][SelectedNodeID+i.ToString()].DCutRHS.Add(this.D_cplex.GetValue(D_INumVar[0]));
                Program.BB.myTree[0][SelectedNodeID+i.ToString()].DCutCoeff.Add(this.D_cplex.GetValues(D_INumVar, 1, numCols));
            }

            // For testing // Show the Results
            //for (int c = 0; c < Program.BB.Ncols + 1; c++)
            //    System.Console.WriteLine(string.Format("Pi{0}={1}", (c + 1), this.D_cplex.GetValue(D_INumVar[c + 1])));
            //Console.WriteLine(this.D_cplex.GetObjValue());

            //Console.WriteLine(this.D_cplex.GetObjective());
            this.D_cplex.Delete(_IAddableVar.ToArray());
        }
    }
}
